<html>
	<head>
		<meta charset="utf-8"/>
		<title>Coloring Geometry</title>
		<style>
			body {
				background-color: black;
				padding: 0px;
				margin: 0px;
				display: flex;
				flex-direction: row;
			}

			.box {
				display: flex;
				flex-direction: row;
			}
		</style>
		<style>
			input[type=range] {
				-webkit-appearance: none;
				height: 80px;
				width: 400px;
				margin-left: -140px;
				margin-right: -140px;
				margin-top: 200px;
				margin-bottom: 200px;
				transform: rotate(270deg);
				background: transparent;
				border: 2px solid white;
				border-radius: 2px;
			}

			input[type=range]::-webkit-slider-thumb {
				-webkit-appearance: none;
				height: 76px;
				width: 20;
				cursor: pointer;
				margin-left: 0px;
			}

			#redSlider::-webkit-slider-thumb {
				background: tomato;
			}

			#greenSlider::-webkit-slider-thumb {
				background: springgreen;
			}

			#blueSlider::-webkit-slider-thumb {
				background: royalblue;
			}

			input[type=range]:focus {
				outline: none;
			}
		</style>
	</head>
	<body>
		<canvas id="space"></canvas>
		<div class="box">
			<input type="range" id="redSlider" min="0" max="255">
			<input type="range" id="greenSlider" min="0" max="255">
			<input type="range" id="blueSlider" min="0" max="255">
		</div>
		<script>
			class Matrix {
				constructor(...values) {
					this.values = values
				}
				col(x) {
					return new Vector(this.values[0 + x], this.values[3 + x], this.values[6 + x])
				}
				row(y) {
					return new Vector(this.values[3*y], this.values[1 + 3*y], this.values[2 + 3*y])
				}
				by(vector) {
					return new Vector(
						this.row(0).by(vector),
						this.row(1).by(vector),
						this.row(2).by(vector),
					)
				}
			}

			class Vector {
				constructor(x, y, z) {
					this.x = x
					this.y = y
					this.z = z
				}
				get length() {
					return Math.sqrt(x * x + y * y + z * z)
				}
				draw() {
					graphics.beginPath()
					graphics.fillStyle = `rgb(${x*ratio+127},${g*ratio+127},${b*ratio+127})`
					graphics.moveTo(px(this.x), px(this.y))
					graphics.arc(px(this.x), px(this.y), radius, 0, 2 * Math.PI, false)
					graphics.fill()
				}
				by(vector) {
					return this.x*vector.x + this.y*vector.y + this.z*vector.z
				}
				times(scalar) {
					return new Vector(this.x*scalar, this.y*scalar, this.z*scalar)
				}
				rotate(Ox, Oy, Oz) {
					let vector = this
					if (Ox != 0) {
						vector = new Matrix(
							1,	0,				0,
							0,	+Math.cos(Ox),	-Math.sin(Ox),
							0,	+Math.sin(Ox),	+Math.cos(Ox),
						).by(vector)
					}
					if (Oy != 0) {
						vector = new Matrix(
							+Math.cos(Oy),	0,	-Math.sin(Oy),
							0,				1,	0,
							+Math.sin(Oy),	0,	+Math.cos(Oy),
						).by(vector)
					}
					if (Oz != 0) {
						vector = new Matrix(
							+Math.cos(Oz),	-Math.sin(Oz),	0,
							+Math.sin(Oz),	+Math.cos(Oz),	0,
							0,				0,				1,
						).by(vector)
					}
					this.x = vector.x
					this.y = vector.y
					this.z = vector.z
				}
				plus(vector) {
					return new Vector(this.x + vector.x, this.y + vector.y, this.z + vector.z)
				}
				to(vector) {
					return new Vector(vector.x - this.x, vector.y - this.y, vector.z - this.z)
				}
			}

			const px = (value) => (value + 1) * canvas.height/2
			const rgb = (value) => value * 255

			class Edge {
				constructor(A, B) {
					this.M1 = A
					this.M2 = B
				}
				draw() {
					const v = (this.center.z + 2) * 100
					graphics.strokeStyle = `rgb(${v}, ${v}, ${v})`
					graphics.lineCap = 'round'
					graphics.lineWidth = (this.center.z + 1) * 2 + 1
					graphics.beginPath()
					graphics.moveTo(px(this.M1.x), px(this.M1.y))
					graphics.lineTo(px(this.M2.x), px(this.M2.y))
					graphics.stroke()
				}
				get center() {
					return this.M1.plus(this.M2).times(1/2)
				}
			}

			class Cursor extends Vector {
				constructor(r, g, b) {
					super(r, g, b)
				}
				get r() { return this.x }
				get g() { return this.y }
				get b() { return this.z }
				draw() {
					let rAxis = B.to(C)
					let gAxis = B.to(B1)
					let bAxis = B.to(A)
					let point = B.plus(rAxis.times(this.r)).plus(gAxis.times(this.g).plus(bAxis.times(this.b)))
					graphics.setLineDash([4, 6])
					graphics.lineWidth = (point.z + 1) * 2 + 1
					graphics.strokeStyle = `rgb(${rgb(this.r)}, ${rgb(this.g)}, ${rgb(this.b)})`
					graphics.beginPath()
					graphics.moveTo(px(point.x) + radius, px(point.y))
					graphics.arc(px(point.x), px(point.y), radius, 0, 2 * Math.PI, false)
					graphics.stroke()
					graphics.setLineDash([])
				}
				replace(r, g, b) {
					this.x = r
					this.y = g
					this.z = b
				}
				move(dr, dg, db) {
					this.replace(this.r + dr, this.g + dg, this.b + db)
				}
			}
		</script>
		<script>
			const canvas = document.getElementById('space')

			const graphics = canvas.getContext('2d')
			var foreground = 'white'
			var background = 'black'

			const radius = 10
			const side = 2/Math.sqrt(3)

			const A		= new Vector(-side/2, -side/2, +side/2)
			const B		= new Vector(-side/2, -side/2, -side/2)
			const C		= new Vector(+side/2, -side/2, -side/2)
			const D		= new Vector(+side/2, -side/2, +side/2)
			const A1	= new Vector(-side/2, +side/2, +side/2)
			const B1	= new Vector(-side/2, +side/2, -side/2)
			const C1	= new Vector(+side/2, +side/2, -side/2)
			const D1	= new Vector(+side/2, +side/2, +side/2)

			const edges = [
				new Edge(A, B),
				new Edge(B, C),
				new Edge(C, D),
				new Edge(D, A),
				new Edge(A1, B1),
				new Edge(B1, C1),
				new Edge(C1, D1),
				new Edge(D1, A1),
				new Edge(A, A1),
				new Edge(B, B1),
				new Edge(C, C1),
				new Edge(D, D1),
			]

			function draw() {
				edges.sort((edge) => edge.center.z)
				graphics.fillStyle = background
				graphics.fillRect(0, 0, canvas.width, canvas.height)
				for (let i = 0; i < 6; i++) {
					edges[i].draw()
				}
				cursor.draw()
				for (let i = 6; i < 12; i++) {
					edges[i].draw()
				}
			}

			function updateCanvasSize() {
				canvas.width = window.innerHeight
				canvas.height = window.innerHeight
				draw()
			}

			cursor = new Cursor(0.5, 0.5, 0.5)
			const vertices = [
				A, B, C, D, A1, B1, C1, D1
			]

			function rotate(x, y, z) {
				vertices.forEach(vertex => {
					vertex.rotate(x, y, z)
				})
			}
			rotate(-0.2, 0.3, 0)

			updateCanvasSize()

			window.addEventListener('resize', updateCanvasSize)

			const rp = (value) => value/canvas.height*2 - 1

			canvas.addEventListener('mouseleave', draw)

			document.body.addEventListener('wheel', (event) => {
				rotate(0, event.deltaX/500, event.deltaY/500)
				draw()
			})

			let wheelPressed = false
			document.body.addEventListener('mousedown', (event) => {
				if (event.button == 1) wheelPressed = true
			})

			document.body.addEventListener('mouseup', (event) => {
				if (event.button == 1) wheelPressed = false
			})

			document.body.addEventListener('mousemove', (event) => {
				if (wheelPressed) {
					rotate(-event.movementY/500, -event.movementX/500, 0)
					draw()
				}
			})

			const sliders = {
				red: document.getElementById('redSlider'),
				green: document.getElementById('greenSlider'),
				blue: document.getElementById('blueSlider'),
			}

			sliders.red.addEventListener('mousemove', () => {
				cursor.x = sliders.red.value/255
				draw()
			})

			sliders.green.addEventListener('mousemove', () => {
				cursor.y = sliders.green.value/255
				draw()
			})

			sliders.blue.addEventListener('mousemove', () => {
				cursor.z = sliders.blue.value/255
				draw()
			})
		</script>
	</body>
</html>